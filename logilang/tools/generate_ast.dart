import 'dart:io';

import 'package:path/path.dart' as p;

void main(List<String> args) {
  if (args.isEmpty) {
    print('Usage: generate_ast <output directory>');
    exit(-1);
  }

  String outputDir = args[0];

  GenerateAst ast = GenerateAst();

  ast.defineAst(outputDir, "Expr", [
    "Assign   : Token name, Expr value",
    "Binary   : Expr left, Token operator, Expr right",
    "Grouping : Expr expression",
    "Literal  : Object value",
    "Unary    : Token operator, Expr right",
    "Variable : Token name",
  ]);

  ast.defineAst(outputDir, "Stmt", [
    "Expression : Expr expression",
    "Print      : Expr expression",
    "Var        : Token name, Expr? initializer",
  ]);
}

class GenerateAst {
  late List<String> types;

  void defineAst(String outputDir, String baseName, List<String> types) {
    this.types = types;

    var filePath = p.join(
        Directory.current.path, '$outputDir/${baseName.toLowerCase()}.dart');

    final File file = File(filePath);

    IOSink sink = file.openWrite();

    sink.writeln("import 'token.dart';");

    if (baseName == 'Stmt') {
      sink.writeln("import 'expr.dart';");
    }
    sink.writeln();

    sink.writeln("""
// -----------------------------------------------------------
// Warning! This code was generated by tools/generate_ast.dart
// -----------------------------------------------------------
    """);

    defineVisitor(sink, baseName);
    sink.writeln('');

    sink.writeln('abstract class $baseName {');
    // The base accept() method.
    sink.writeln('  R accept<R>(${baseName}Visitor<R> visitor);');

    sink.writeln('}');

    // The AST classes.
    for (String type in types) {
      String className = type.split(":")[0].trim();
      String fields = type.split(":")[1].trim();
      defineType(sink, baseName, className, fields);
    }

    sink.close();
  }

  void defineVisitor(IOSink sink, String baseName) {
    sink.writeln("abstract class ${baseName}Visitor<R> {");

    for (String type in types) {
      String typeName = type.split(":")[0].trim();
      sink.writeln(
          '  R visit$typeName$baseName($typeName ${baseName.toLowerCase()});');
    }
    sink.writeln("}");
  }

  void defineType(
      IOSink sink, String baseName, String className, String fieldList) {
    sink.writeln('');

    // -------------------------------------------------------
    // ------------- Sub class
    // -------------------------------------------------------
    sink.writeln('class $className extends $baseName {');

    // -------------------------------------------------------
    // ------------- Sub class Fields.
    // -------------------------------------------------------
    List<String> fields = fieldList.split(", ");

    for (String field in fields) {
      sink.writeln('  final $field;');
    }
    sink.writeln();

    // -------------------------------------------------------
    // ------------- Constructor.
    // -------------------------------------------------------
    sink.write('  $className(');
    List<String> conFields = fieldList.split(', ');

    int cnt = 0;
    for (String field in conFields) {
      List<String> fs = field.split(' ');

      if (cnt < conFields.length - 1) {
        sink.write(' this.${fs[1]},');
      } else {
        sink.write(' this.${fs[1]}');
      }
      cnt++;
    }

    sink.writeln(');');

    // -------------------------------------------------------
    // ------------ Visitor pattern.
    // -------------------------------------------------------
    sink.writeln();
    sink.writeln("  @override");
    sink.writeln("  R accept<R>(${baseName}Visitor<R> visitor) {");
    sink.writeln('    return visitor.visit$className$baseName(this);');
    sink.writeln("  }");

    sink.writeln('}');
  }
}
