import 'dart:io';

import 'package:path/path.dart' as p;

void main(List<String> args) {
  if (args.isEmpty) {
    print('Usage: generate_ast <output directory>');
    exit(-1);
  }

  String outputDir = args[0];

  GenerateAst ast = GenerateAst();

  ast.defineAst(outputDir, "Expr");
}

class GenerateAst {
  List<String> types = [
    "Binary: Expr left, Token operator, Expr right",
    "Grouping : Expr expression",
    "Literal: Object value",
    "Unary: Token operator, Expr right",
  ];

  void defineAst(String outputDir, String baseName) {
    var filePath = p.join(Directory.current.path, outputDir);

    final File file = File(filePath);

    IOSink sink = file.openWrite();

    sink.writeln("import 'token.dart';");
    sink.writeln();

    sink.writeln("""
// -----------------------------------------------------------
// Warning! This code was generated by tools/generate_ast.dart
// -----------------------------------------------------------
    """);

    defineVisitor(sink, baseName);
    sink.writeln('');

    sink.writeln('abstract class $baseName {');
    // The base accept() method.
    sink.writeln("  R accept<R>(Visitor<R> visitor);");

    sink.writeln('}');

    // The AST classes.
    for (String type in types) {
      String className = type.split(":")[0].trim();
      String fields = type.split(":")[1].trim();
      defineType(sink, baseName, className, fields);
    }

    sink.close();
  }

  void defineVisitor(IOSink sink, String baseName) {
    sink.writeln("abstract class Visitor<R> {");

    for (String type in types) {
      String typeName = type.split(":")[0].trim();
      sink.writeln(
          '  R visit$typeName$baseName($typeName ${baseName.toLowerCase()});');
    }
    sink.writeln("}");
  }

  void defineType(
      IOSink sink, String baseName, String className, String fieldList) {
    sink.writeln('');

    // -------------------------------------------------------
    // ------------- Sub class
    // -------------------------------------------------------
    sink.writeln('class $className extends $baseName {');

    // -------------------------------------------------------
    // ------------- Sub class Fields.
    // -------------------------------------------------------
    List<String> fields = fieldList.split(", ");

    for (String field in fields) {
      sink.writeln('  final $field;');
    }
    sink.writeln();

    // -------------------------------------------------------
    // ------------- Constructor.
    // -------------------------------------------------------
    sink.write('  $className(');
    List<String> conFields = fieldList.split(', ');

    int cnt = 0;
    for (String field in conFields) {
      List<String> fs = field.split(' ');

      if (cnt < conFields.length - 1) {
        sink.write(' this.${fs[1]},');
      } else {
        sink.write(' this.${fs[1]}');
      }
      cnt++;
    }

    sink.writeln(');');

    // -------------------------------------------------------
    // ------------ Visitor pattern.
    // -------------------------------------------------------
    sink.writeln();
    sink.writeln("  @override");
    sink.writeln("  R accept<R>(Visitor<R> visitor) {");
    sink.writeln('    return visitor.visit$className$baseName(this);');
    sink.writeln("  }");

    sink.writeln('}');
  }
}

void _testAstPrinter() {}

// ---------------------------------------------------------
// An example of what is generated
/*
abstract class Visitor<R> {
  R visitBinaryExpr(Binary expr);
  R visitGroupingExpr(Grouping expr);
  R visitLiteralExpr(Literal expr);
  R visitUnaryExpr(Unary expr);
}

abstract class Expr {
  R accept<R>(Visitor<R> visitor);
}

class Binary extends Expr {
  final Expr left;
  final Token operator;
  final Expr right;

  Binary( this.left, this.operator, this.right);

  @override
  R accept<R>(Visitor<R> visitor) {
    return visitor.visitBinaryExpr(this);
  }
}

class Grouping extends Expr {
  final Expr expression;

  Grouping( this.expression);

  @override
  R accept<R>(Visitor<R> visitor) {
    return visitor.visitGroupingExpr(this);
  }
}

class Literal extends Expr {
  final Object value;

  Literal( this.value);

  @override
  R accept<R>(Visitor<R> visitor) {
    return visitor.visitLiteralExpr(this);
  }
}

class Unary extends Expr {
  final Token operator;
  final Expr right;

  Unary( this.operator, this.right);

  @override
  R accept<R>(Visitor<R> visitor) {
    return visitor.visitUnaryExpr(this);
  }
}
*/
